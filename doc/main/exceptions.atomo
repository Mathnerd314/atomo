#title:{Exception Handling}tag:"exceptions"

#define:{
    error: v
    > undefined
}body:{
    Signals #atomo:v as an error. If the signal exits normally, a debugger is started; hence, this method never exits normally.

    #example:({
        { "x" print; error: 1; "y" print } call
    })
}

#define:{
    action catch: recover
    | action is-a?: Block
    | recover is-a?: Block
    > any
}body:{
    Execute #atomo:(action call), catching any errors and passing them to #atomo:recover for handling.

    Yields the result of #atomo:action or #atomo:recover.

    #example:({
        { error: @error } catch: { e | @(got: e) }
        { @ok } catch: { @caught }
    })
}

#define:{
    action catch: recover ensuring: cleanup
    | [action, recover, cleanup] all?: @(is-a?: Block)
    > any
}body:{
    Execute #atomo:(action call), catching any errors and passing them to #atomo:recover for handling, and ensuring that #atomo:cleanup is called after the action is executed.

    Yields the result of #atomo:action or #atomo:recover.

    #example:({
        { @ok } catch: { @caught } ensuring: { "cleaning up" print }
        { error: @not-ok } catch: { @caught } ensuring: { "cleaning up" print }
    })
}

#define:{
    action handle: branches
    | action is-a?: Block
    | branches is-a?: Block
    > any
}body:{
    Similar to #atomo:(catch:), but #atomo:branches is a block containing exception patterns bound to the action to take if they're thrown. If none of the exceptions match any of the patterns, the exception is re-thrown.

    #example:({
        { error: @foo } handle: { @foo -> 1; @bar -> 2 }
        { error: @bar } handle: { @foo -> 1; @bar -> 2 }
        { error: @baz } handle: { @foo -> 1; @bar -> 2 }
        { @ok } handle: { @foo -> 1; @bar -> 2 }
    })
}

#define:{
    action handle: branches ensuring: cleanup
    | [action, branches, cleanup] all?: @(is-a?: Block)
    > any
}body:{
    Similar to #atomo:(handle:), but with an #atomo:(ensuring:) block.

    #example:({
        { error: @foo } handle: { @foo -> 1 } ensuring: { "hi" print }
        { error: @baz } handle: { @foo -> 1 } ensuring: { "hi" print }
        { @ok } handle: { @foo -> 1 } ensuring: { "hi" print }
    })
}

#define:{
    action ensuring: cleanup
    | action is-a?: Block
    | cleanup is-a?: Block
    > any
}body:{
    Execute #atomo:(action call), ensuring that #atomo:cleanup is called after the action is executed.

    Yields the result of #atomo:action.

    #example:({
        { @ok } ensuring: { "cleaning up" print }
        { error: @not-ok } ensuring: { "cleaning up" print }
    })
}

#define:{
    value ensuring: cleanup do: action
    | cleanup is-a?: Block
    | action is-a?: Block
    > any
}body:{
    Similar to #atomo:(ensuring:), but #atomo:value is passed to both blocks. This makes things like file opening and closing very natural.

    Yields the result of #atomo:action.

    #example:({
        File (new: "example-file") ensuring: @close do: @(display: "Hello!")
    })

    #(@ok = File delete: "example-file")
}
