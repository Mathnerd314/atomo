{ define: *handlers* as: []
  define: *restarts* as: []

  (super) Error = Object clone

  for-macro Handler = Object clone do: { handle: _ := @ok }
  for-macro Restart = Object clone

  Restart new: n as: (a: Block) in: (c: Continuation) :=
    Restart clone do:
      { name = n
        action = a
        context = c
      }

  macro action with-restarts: (restarts: Block) :=
    { rs = restarts contents map:
        { `(~n -> ~e) |
          e type match: {
            @block -> `(Restart new: ~n as: ~e in: cc)
            _ -> `(Restart new: ~n as: { ~e } in: cc)
          }
        }

      `({ cc | ~action with-restarts: ~(`List new: rs) } call/cc)
    } call

  (action: Block) with-restarts: (restarts: List) :=
    with: *restarts* as: (restarts .. *restarts* _?) do: action

  (super) signal: v :=
    { *handlers* _? map: @(handle: v)
      @ok
    } call

  (super) error: e :=
    { err =
        if: (e is-a?: Error)
          then: { e }
          else: { e clone do: { delegates-to: Error } }

      signal: err

      with-output-to: Port standard-error do: {
        '-' (repeat: 78) print
        ("*** " .. e show) print

        when: *restarts* _? empty?
          do: { halt }

        "" print
        "restarts:" print

        index = 0
        *restarts* _? each:
          { restart |
            ("  " .. index show .. ": " .. restart name show) print
            index = index + 1
          }
      }

      chosen = *restarts* _? at: read
      chosen context yield: chosen action call
    } call

  (super) restart: name with: (params: List) :=
    *restarts* _? (filter: { r | r name == name }) match: {
      (r . _) -> r context yield: r action (call: params)
      [] -> error: @(unknown-restart: name)
    }

  (super) restart: name :=
    restart: name with: []

  (a: Block) bind: (bs: Block) :=
    { h = Handler clone

      bs contents map:
        { `(~c -> ~e) |
          if: (e type == @block)
            then: { @handle: define-on: h with: [`(e: ~(c evaluate-in: sender)) as: Pattern] as: `(~e call: [e]) in: sender }
            else: { @handle: define-on: h with: [c as: Pattern] as: e in: sender }
        }

      with: *handlers* as: (h . *handlers* _?) do: a
    } call
} call
