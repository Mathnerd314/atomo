Default-Debugger = Object clone do:
  { run: e :=
      { Restart show-options-for: e

        "!> " display

        Restart (get: read) jump: []
      } call
  }

define: current-debugger as: Default-Debugger

{ define: *handlers* as: []
  define: *restarts* as: []

  (super) Error = Object clone

  for-macro Handler = Object clone do: { handle: _ := @ok }
  for-macro Restart = Object clone

  Restart show-options-for: e :=
    { '-' (repeat: 78) print
      ("*** " .. e show) print

      when: *restarts* _? empty?
        do: { halt }

      "" print
      "restarts:" print

      *restarts* _? (zip: (0 .. *restarts* _? length)) map:
        { choice |
          [index, name] = [choice to, choice from from]
          ("  " .. index show .. ": " .. name show) print
        }
    } call

  Restart get: (n: Integer) :=
    *restarts* _? (at: n) to

  Restart new: (a: Block) in: (c: Continuation) :=
    Restart clone do:
      { jump: as := c yield: (a call: as)
        action = a
        context = c
      }

  macro action with-restarts: (restarts: Block) :=
    { rs = restarts contents map:
        { `(~n -> ~e) |
          e type match: {
            @block -> `(~n -> Restart new: ~e in: cc)
            _ -> `(~n -> Restart new: { ~e } in: cc)
          }
        }

      `({ cc | ~action with-restarts: ~(`List new: rs) } call/cc)
    } call

  (action: Block) with-restarts: (restarts: List) :=
    with: *restarts* as: (restarts .. *restarts* _?) do: action

  (super) signal: v :=
    { *handlers* _? map: @(handle: v)
      @ok
    } call

  (super) error: e :=
    { err =
        if: (e is-a?: Error)
          then: { e }
          else: { e clone do: { delegates-to: Error } }

      signal: err

      with-output-to: Port standard-error do: {
        current-debugger _? run: e
      }
    } call

  (super) restart: name := restart: name with: []

  (super) restart: name with: (params: List) :=
    *restarts* _? (lookup: name) match: {
      @(ok: r) ->
        r jump: params

      @none ->
        error: @(unknown-restart: name)
    }

  (super) find-restart: name :=
    *restarts* _? lookup: name

  (a: Block) bind: (bs: Block) :=
    { h = Handler clone

      bs contents map:
        { `(~c -> ~e) |
          [arg, expr] =
            condition: {
              e type == @block && e arguments empty? not ->
                [`(e: ~(c evaluate-in: sender)) as: Pattern, `(~e call: [e])]

              e type == @block ->
                [c as: Pattern, `(~e call)]

              otherwise ->
                [c as: Pattern, e]
            }

          @handle: define-on: h with: [arg] as: expr in: sender
        }

      with: *handlers* as: (h . *handlers* _?) do: a
    } call
} call
